function [pow_new csd_new] = ft_csd_eigendecomp(spectrum,cutdatindcmb,component,outprod)

% ft_csd_eigendecomp computes an NZPL CSD (or equivilent for the real part
% of the CSD) from spectral estimates generated by ft_freqanalysis, and
% feeds these back to ft_freqanalysis.
% The process involves a segmentation of the imaginary (or real) part of the
% cross-spactra and computes an etimate of the imaginary (or real) only
% power by eigendecomposition of the imaginary (or real) CSD matrix. THis
% estimate is added to the diagonal of the the matrix. 
%
% If using the component is 'imag'. an additional outprod paramater can be
% specfied, which computes the outerproduct of the re-estimate power. This
% matirx is added to the real part of the new CSD matrix, instead of 
% only the diagonal. THis can be used for estimating forward projection of
% the eigencecomposition for improved source analysis. 
%
% N.B. The decompostion of the real CSD yields two eigenvectors (see ref for 
% details), use  'real1' or 'real2' to specify whether to use 1st or 2nd 
% eigenvector. 
%
% Use as
%  [pow_new csd_new] = ft_csd_eigendecomp(spectrum,component)
% where
% spectrum     = is the full spectrum, generated within ft_freqanalsyis
%                   dimensions are [n_tapers x n_chans x n_fois x n_tois].
% cutdatindcmb = is a n_chancmbs x 2 matrix of indices of channel pairs to 
%                   compute CSDs for.
% component    = (optional)  which component of the cross-spectra to 
%                  decompose:  'imag', 'real1' or 'real2'. (Default = 'imag').
% outprod    = (optional)  specifes whther to additional compute the 
%                outerporduct of the estimated power 
%                  (only valid if component = 'imag'. Default = 'no');
%
% pow_new      = is a n_chans x 1 vector of eigendecomposed power estimates
% csd_new      = is a n_chancmbs x 2 vector of imaginary (or real) CSDs
%
% Reference:
% Drakesmith, et al (2013), DOI: 10.1371/journal.pone.0081553
% 
% Copyright (C) 2013, Mark Drakesmith
%
% This file is part of FieldTrip, see http://www.ru.nl/neuroimaging/fieldtrip
% for the documentation and details.
%
%    FieldTrip is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    FieldTrip is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with FieldTrip. If not, see <http://www.gnu.org/licenses/>.
%
% $Id$

revision = '$Id$';

if ~exist(component)
    component='imag';
end

if ~exist(outprod)
    outprod='no';
end

if  strcmp(component,'real1')
    eig_idx=1;
    isimag=0;
elseif strcmp(component,'real2') 
    eig_idx=2;
    isimag=0;
elseif strcmp(component,'imag') 
    eig_idx=1;
    isimag=1;
else 
    error('Unrecognised output component. Valid values: ''imag'',''real1'',''real2''.');
end

if strcmp(outprod,'yes') & isimag
    outprod=1;
else
    outprod=0;
end


sen_idx=unique(cutdatindcmb);

n_tap=size(spectrum,1);
n_sen=size(spectrum,2);
n_foi=size(spectrum,3);
n_toi=size(spectrum,4);


% reshape(spectrum,[n_tap n_sen n_foi 1]);
% % 
% % if n_toi<1
% %     no_toi=1;
% %     spectrum(:,:,:)
% % end


for i_tap=1:n_tap
    for i_foi=1:n_foi
        for i_toi=1:n_toi
            spect_temp=spectrum(i_tap,sen_idx,i_foi,i_toi);
            
            % compute CSD
            csd=spect_temp'*spect_temp;
            % get specifed compoent of CSD
            csd_comp=eval([component(1:4) '(csd);']);
            
            % perform eigenvector decomposition on CSD component
            [e_vec,e_val] = eig(csd_comp);
            
            % sort eigenvalues
            [val,idx]=sort(abs(diag(e_val)),'descend');
  
            % get relevent eigen vector/values
            q = e_vec(:,idx(eig_idx));
            lambda = e_val(idx(eig_idx),idx(eig_idx));
            
            % get new power estimate
            eig_diag=abs((q).^2.*lambda);
            
             % if imag, force CSD to be imaginary
             if isimag
                 csd_comp=csd_comp.*sqrt(-1);
             end
             % add power estimate to diagonal of compoent CSD
             csd_comp2=zeros(n_sen);
             
             if outprod
                 %  compute outerproduct, if specfied
                 eig_comp2=2.*(sqrt(eig_diag)*sqrt(eig_diag)');
             else
                 eig_comp2=2.*diag(eig_diag);
             end
             
             
             csd_comp2(sen_idx,sen_idx)=csd_comp.*(1-eye(size(csd_comp))) + eig_comp2;
%             
            
            % put values in array to send back to ft_freqanalysis
            for i_sen=1:size(cutdatindcmb,1)
                csd_new(i_tap,i_sen,i_foi,i_toi)=csd_comp2(cutdatindcmb(i_sen,1),cutdatindcmb(i_sen,2));
            end
            
            for i_sen=1:size(sen_idx,1)
                pow_new(i_tap,i_sen,i_foi,i_toi)=csd_comp2(sen_idx(i_sen),sen_idx(i_sen));
            end
            
            
        end
    end
end


    
            
            
