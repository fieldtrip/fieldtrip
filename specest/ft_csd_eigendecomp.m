function [pow_new csd_new] = ft_csd_eigendecomp(spectrum,cutdatindcmb,component)

% ft_csd_eigendecomp computes an NZPL CSD (or equivilent for the real part
% of the CSD) from spectral estimates generated by ft_freqanalysis, and
% feeds these back to ft_freqanalysis.
% The process involves a segmentation of the imaginary (or real) part of the
% cross-spactra and computes an etimate of the imaginary (or real) only
% power by eigendecomposition of the imaginary (or real) CSD matrix. 
%
% N.B. The decompostion of the real CSD yields two eigenvectors (see ref for 
% details), use  'real1' or 'real2' to specify whether to use 1st or 2nd 
% eigenvector. 
%
% Use as
%  [pow_new csd_new] = ft_csd_eigendecomp(spectrum,component)
% where
% spectrum     = is the full spectrum, generated within ft_freqanalsyis
%                   dimensions are [n_tapers x n_chans x n_fois x n_tois].
% cutdatindcmb = is a n_chancmbs x 2 matrix of indices of channel pairs to 
%                   compute CSDs for.
% component    = (optional)  which component of the cross-spectra to 
%                   decompose:  'imag', 'real1' or 'real2'. (Default = 'imag').
%
% pow_new      = is a n_chans x 1 vector of eigendecomposed power estimates
% csd_new      = is a n_chancmbs x 2 matrix of imaginary (or real) CSDs
%                   dimensions are [n_tapers x n_chancmbs x n_fois x n_tois].
% cutdatindcmb = list of indices for channel pairs to compute CSDs for
% component    = (optional)  which component of the cross-spectra to 
%                   decompose  'imag', 'real1' or 'real2'. Default is 'imag'.
%
% pow_new      = is a n_chans x 1 vector of eigendecomposed power estimates
% csd_new      = is a n_chancmbs x 2 vector of imaginary (or real) CSDs
%
% Reference:
% Drakesmith, et al (2013), DOI: 10.1371/journal.pone.0081553
% 
% Copyright (C) 2013, Mark Drakesmith
%
% This file is part of FieldTrip, see http://www.ru.nl/neuroimaging/fieldtrip
% for the documentation and details.
%
%    FieldTrip is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    FieldTrip is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with FieldTrip. If not, see <http://www.gnu.org/licenses/>.
%
% $Id$

revision = '$Id$';

if ~exist(component)
    component='imag';
end

if  strcmp(component,'real1')
    eig_idx=1;
    isimag=0;
elseif strcmp(component,'real2') 
    eig_idx=2;
    isimag=0;
elseif strcmp(component,'imag') 
    eig_idx=1;
    isimag=1;
else 
    error('Unrecognised output component. Valid values: ''imag'',''real1'',''real2''.');
end


sen_idx=unique(cutdatindcmb);

n_tap=size(spectrum,1);
n_sen=size(spectrum,2);
n_foi=size(spectrum,3);
n_toi=size(spectrum,4);


% reshape(spectrum,[n_tap n_sen n_foi 1]);
% % 
% % if n_toi<1
% %     no_toi=1;
% %     spectrum(:,:,:)
% % end


for i_tap=1:n_tap
    for i_foi=1:n_foi
        for i_toi=1:n_toi
            spect_temp=spectrum(i_tap,sen_idx,i_foi,i_toi);
            
            % compute CSD
            csd=spect_temp'*spect_temp;
            % get specifed compoent of CSD
            csd_comp=eval([component(1:4) '(csd);']);
            
            % perform eigenvector decomposition on CSD component
            [e_vec,e_val] = eig(csd_comp);
            
            % sort eigenvalues
            [val,idx]=sort(abs(diag(e_val)),'descend');
  
            % get relevent eigen vector/values
            q = e_vec(:,idx(eig_idx));
            lambda = e_val(idx(eig_idx),idx(eig_idx));
            
            % get new power estimate
            eig_diag=abs((q).^2.*lambda);
            
             % if imag, force CSD to be imaginary
             if isimag
                 csd_comp=csd_comp.*sqrt(-1);
             end
             % add power estimate to diagonal of compoent CSD
             csd_comp2=zeros(n_sen);
             csd_comp2(sen_idx,sen_idx)=csd_comp.*(1-eye(size(csd_comp))) + 2.*diag(eig_diag);
%             
            
            % put values in array to send back to ft_freqanalysis
            for i_sen=1:size(cutdatindcmb,1)
                csd_new(i_tap,i_sen,i_foi,i_toi)=csd_comp2(cutdatindcmb(i_sen,1),cutdatindcmb(i_sen,2));
            end
            
            for i_sen=1:size(sen_idx,1)
                pow_new(i_tap,i_sen,i_foi,i_toi)=csd_comp2(sen_idx(i_sen),sen_idx(i_sen));
            end
            
            
        end
    end
end


    
            
            
