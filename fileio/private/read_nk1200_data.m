function [dat] = read_nk1200_data(filename, hdr, begsample, endsample, chanindx)

% READ_NK1200_DATA reads NK1200 files (.EEG) that have been generated by
% the Nihon Kohden system. The function constitutes a wrapper around
% BrainStorm3 functionalities
%
% Use as
%   [dat] = read_nk1200_data(filename, hdr, begsample, endsample, chanindx)
%
% The function has not been tested on NK1200 files with multiple epochs
%
% See also READ_NK1200_HEADER, READ_NK1200_EVENT

% Copyright (C) 2018, Arjen Stolk & Sandon Griffin
%
% This file is part of FieldTrip, see http://www.fieldtriptoolbox.org
% for the documentation and details.
%
%    FieldTrip is free software: you can redistribute it and/or modify
%    it under the terms of the GNU General Public License as published by
%    the Free Software Foundation, either version 3 of the License, or
%    (at your option) any later version.
%
%    FieldTrip is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%
%    You should have received a copy of the GNU General Public License
%    along with FieldTrip. If not, see <http://www.gnu.org/licenses/>.
%
% $Id$


% default is to select all channels
if nargin<5
  chanrange{1} = [1 hdr.nChans]; % all channels
else
  if all(find([diff(chanindx) Inf])>1) % if chanindx is consecutively numbered
    chanrange{1} = [chanindx(1) chanindx(end)];
  else % otherwise loop separately per chanindx entry
    chanrange = cell(numel(chanindx), 1);
    for c = 1:numel(chanindx)
      chanrange{c} = [chanindx(c) chanindx(c)];
    end
  end
end

% call BrainStorm's in_fopen_nk
[sFile] = in_fopen_nk(filename);

% check number of epochs/trials
if hdr.nTrials>1
  ft_warning('support for multiple epochs/trials has not been tested')
end

% call BrainStorm's in_fread_nk
num = [];
dat = [];
for e = 1:hdr.nTrials
  for c = 1:numel(chanrange)
    tmp = in_fread_nk(sFile, fopen(filename), e, [begsample endsample], chanrange{c});
    num = [num; tmp]; clear tmp % stack channels
  end
  dat = [dat num]; clear num % append epochs/trials
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F = in_fread_nk(sFile, sfid, iEpoch, SamplesBounds, ChannelsRange)
% IN_FREAD_NK:  Read a block of recordings from a Nihon Kohden file (.EEG)
%
% USAGE:  F = in_fread_nk(sFile, sfid, iEpoch, SamplesBounds, ChannelsRange)
%         F = in_fread_nk(sFile, sfid, iEpoch, SamplesBounds)               : Read all channels
%         F = in_fread_nk(sFile, sfid)                                      : Read all channels, all samples

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
%
% Copyright (c)2000-2018 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
%
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Francois Tadel, 2017
%          Inspired from NK2EDF, Teunis van Beelen, 2007-2017
%          and from the BIOSIG-toolbox http://biosig.sf.net/

% Parse inputs
if (nargin < 5) || isempty(ChannelsRange)
  ChannelsRange = [1, sFile.header.num_channels];
end
if (nargin < 4) || isempty(SamplesBounds)
  if isempty(sFile.epochs)
    SamplesBounds = sFile.prop.samples;
  else
    SamplesBounds = sFile.epochs(iEpoch).samples;
  end
end
if (nargin < 3) || isempty(iEpoch)
  iEpoch = 1;
end

% ===== COMPUTE OFFSETS =====
nChannels     = double(sFile.header.num_channels);
nReadTimes    = SamplesBounds(2) - SamplesBounds(1) + 1;
nReadChannels = double(ChannelsRange(2) - ChannelsRange(1) + 1);
% Data type
bytesPerVal = 2;
dataClass   = 'uint16';

% Data offset in the .EEG file for selected data block
offsetData = sFile.header.ctl(1).data(iEpoch).rec_address;
% Time offset
offsetTime = round(SamplesBounds(1) * nChannels * bytesPerVal);
% Channel offset at the beginning and end of each channel block
offsetChannelStart = round((ChannelsRange(1)-1) * bytesPerVal);
offsetChannelEnd   = (nChannels - ChannelsRange(2)) * bytesPerVal;
% Start reading at this point
offsetStart = offsetData + offsetTime + offsetChannelStart;
% Number of time samples to skip after each channel
offsetSkip = offsetChannelStart + offsetChannelEnd;

% ===== READ DATA BLOCK =====
% Position file at the beginning of the trial
fseek(sfid, offsetStart, 'bof');
% Read trial data
% => WARNING: CALL TO FREAD WITH SKIP=0 DOES NOT WORK PROPERLY
if (offsetSkip == 0)
  F = fread(sfid, [nReadChannels, nReadTimes], dataClass);
else
  precision = sprintf('%d*%s', nReadChannels, dataClass);
  F = fread(sfid, [nReadChannels, nReadTimes], precision, offsetSkip);
end
% Check that data block was fully read
if (numel(F) < nReadTimes * nReadChannels)
  % Error message
  disp(sprintf('BST> ERROR: File is truncated (%d values were read instead of %d)...', numel(F), nReadTimes * nReadChannels));
  % Pad with zeros
  Ftmp = zeros(nReadChannels, nReadTimes);
  Ftmp(1:numel(F)) = F(:);
  F = Ftmp;
end

% Apply channel gains
F = bst_bsxfun(@minus, F, sFile.header.channel_digoffset(ChannelsRange(1):ChannelsRange(2))');
F = bst_bsxfun(@times, F, sFile.header.channel_gains(ChannelsRange(1):ChannelsRange(2))');


function C = bst_bsxfun(fun, A, B)
% BST_BSXFUN:  Compatible version of bsxfun function.
%
% DESCRIPTION:
%     Matlab function bsxfun() is a useful, fast, and memory efficient
%     way to apply element-by-element operations on huge matrices.
%     The problem is that this function only exists in Matlab versions >= 7.4
%     This function check Matlab version, and use bsxfun if possible, if not
%     it finds another way to perform the same operation.

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
%
% Copyright (c)2000-2018 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
%
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Francois Tadel, 2010

% Old Matlab version: do it old school
if ~exist('bsxfun', 'builtin')
  sA = [size(A,1), size(A,2), size(A,3)];
  sB = [size(B,1), size(B,2), size(B,3)];
  % If arguments were not provided in the correct order
  if all(sA == [1 1 1]) || all(sB == [1 1 1])
    C = fun(A, B);
  elseif all(sA == sB)
    C = fun(A, B);
    % Dim 1
  elseif (sB(1) == 1) && (sA(2) == sB(2)) && (sA(3) == sB(3))
    C = fun(A, repmat(B, [sA(1), 1, 1]));
  elseif (sA(1) == 1) && (sA(2) == sB(2)) && (sA(3) == sB(3))
    C = fun(repmat(A, [sB(1), 1, 1]), B);
    % Dim 2
  elseif (sA(1) == sB(1)) && (sB(2) == 1) && (sA(3) == sB(3))
    C = fun(A, repmat(B, [1, sA(2), 1]));
  elseif (sA(1) == sB(1)) && (sA(2) == 1) && (sA(3) == sB(3))
    C = fun(repmat(A, [1, sB(2), 1]), B);
    % Dim 3
  elseif (sA(1) == sB(1)) && (sA(2) == sB(2)) && (sB(3) == 1)
    C = fun(A, repmat(B, [1, 1, sA(3)]));
  elseif (sA(1) == sB(1)) && (sA(2) == sB(2)) && (sA(3) == 1)
    C = fun(repmat(A, [1, 1, sB(3)]), B);
  else
    error('A and B must have enough common dimensions.');
  end
  % New Matlab version: use bsxfun
else
  C = bsxfun(fun, A, B);
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [sFile, ChannelMat] = in_fopen_nk(DataFile)
% IN_FOPEN_EDF: Open a Nihon Kohden file (.EEG / .PNT / .LOG / .21E)
%
% USAGE:  [sFile, ChannelMat] = in_fopen_nk(DataFile)

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
%
% Copyright (c)2000-2018 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
%
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Francois Tadel, 2017-2018
%          Inspired from NK2EDF, Teunis van Beelen, 2007-2017
%          and from the BIOSIG-toolbox http://biosig.sf.net/


%% ===== GET FILES =====
% Get base filename for all the files
[fPath, fBase] = bst_fileparts(DataFile);
BaseFile = bst_fullfile(fPath, fBase);
% EEG file (mandatory)
EegFile = [BaseFile '.eeg'];
if ~file_exist(EegFile)
  EegFile = [BaseFile '.EEG'];
  if ~file_exist(EegFile)
    error('Could not find .EEG file.');
  end
end
% PNT file (optional)
PntFile = [BaseFile '.pnt'];
if ~file_exist(PntFile)
  PntFile = [BaseFile '.PNT'];
  if ~file_exist(PntFile)
    disp('NK> Warning: Could not find .PNT file.');
    PntFile = [];
  end
end
% LOG file (optional)
LogFile = [BaseFile '.log'];
if ~file_exist(LogFile)
  LogFile = [BaseFile '.LOG'];
  if ~file_exist(LogFile)
    disp('NK> Warning: Could not find .LOG file.');
    LogFile = [];
  end
end
% 21E file (optional)
ElecFile = [BaseFile '.21e'];
if ~file_exist(ElecFile)
  ElecFile = [BaseFile '.21E'];
  if ~file_exist(ElecFile)
    disp('NK> Warning: Could not find .21E electrodes file.');
    LogFile = [];
  end
end


%% ===== READ EEG FILE =====
% Open file
fid = fopen(DataFile, 'rb');
if (fid == -1)
  error('Could not open EEG file.');
end
% Get deviceblock signature
hdr.device = fread(fid, [1 16], '*char');
hdr.version = get_header_version(hdr.device);
if (hdr.version == 0)
  error(['EEG deviceblock has unknown signature: "' hdr.device '"']);
end
% Get controlblock signature
fseek(fid, 129, 'bof');
hdr.control = fread(fid, [1 16], '*char');
if (get_header_version(hdr.control) == 0)
  error(['EEG controlblock has unknown signature: "' hdr.control '"']);
end
% Get waveformdatablock signature
fseek(fid, 6142, 'bof');
signature = fread(fid, [1 1], '*char');
if (signature ~= 1)
  error('waveformdatablock has wrong signature.');
end

% Get number of control blocks
fseek(fid, 145, 'bof');                        % Position:         0x0091
hdr.ctl_cnt = fread(fid, [1 1], 'uint8');
% Get a pointer to the extra block (only valid for newer file formats >= 1200 NK systems)
fseek(fid, 1006, 'bof');                       % Position:         0x03EE
hdr.ext_address = fread(fid, 1, 'uint32');     % extblock_address: VARIABLE
% Consider blocks of 100ms everywhere
hdr.record_duration = 0.1;

% Get all the pointers to all the blocks
for i = 1:hdr.ctl_cnt                               % Ctl block at:     0x0080
  % Get pointer to this block
  fseek(fid, 146 + (i-1) * 20, 'bof');            % Position:         0x0092   (1st ctl block)
  hdr.ctl(i).address = fread(fid, 1, 'uint32');   % ctlblock_address: 0x0400
  % Get number of data blocks
  fseek(fid, hdr.ctl(i).address + 23, 'bof');     % Position:         0x0417
  hdr.ctl(i).data_cnt = fread(fid, [1 1], 'uint8');
  hdr.ctl(i).data = repmat(struct(), 0);
  % Loop on data blocks
  for j = 1:hdr.ctl(i).data_cnt
    % Read data address
    fseek(fid, hdr.ctl(i).address + ((j-1) * 20) + 18, 'bof');            % Position:       0x0412   (1st ctl block)
    dataAddr = fread(fid, 1, 'uint32');                                   % Data block at:  0x17FE
    % Add data block only if it points to a valid address in the file
    if (dataAddr > 0)
      % Save address in structure
      id = length(hdr.ctl(i).data) + 1;
      hdr.ctl(i).data(id).address = dataAddr;
      % Read block start timestamp
      fseek(fid, dataAddr + 5, 'bof');
      timeH = str2double(fread(fid, [1 2], '*char'));
      timeM = str2double(fread(fid, [1 2], '*char'));
      timeS = str2double(fread(fid, [1 2], '*char'));
      hdr.ctl(i).data(id).timestamp = 60*60*timeH + 60*timeM + timeS;
      % Read the sampling rate
      fseek(fid, dataAddr + 26, 'bof');              % Position:   0x1818
      hdr.ctl(i).data(id).sample_rate = bitand(fread(fid, 1, 'uint16'), hex2dec('3fff'));    % Nihon-Kohden int16 format
      
      % Get the channel order from here (older system)
      switch (hdr.version)
        case 1    % Older NK systems: 1100, 2100
          % Read the block information: number of records
          fseek(fid, dataAddr + 28, 'bof');      % Position:   0x181A
          hdr.ctl(i).data(id).num_records = fread(fid, 1, 'uint32');
          % Read number of channels
          fseek(fid, dataAddr + 38, 'bof');      % Position:   0x1824
          hdr.ctl(i).data(id).num_channels = fread(fid, 1, 'uint8') + 1;  % +1 for the STIM channel
          % Read channel order
          for iChan = 1:(hdr.ctl(i).data(id).num_channels - 1)    % -1 because the STIM channel is not listed here
            fseek(fid, dataAddr + 39 + (iChan - 1) * 10, 'bof');  % Position:   0x1825, 0x182F, 0x1839, ...
            hdr.ctl(i).data(id).channel_list(iChan) = fread(fid, 1, 'uint8') + 1;
          end
          % Define pointer to the beginning of the recordings
          hdr.ctl(i).data(id).rec_address = hdr.ctl(i).data(id).address + 39 + (hdr.ctl(i).data(id).num_channels - 1) * 10;   % -1 because the STIM channel is not listed here
          % Compute number of samples
          hdr.ctl(i).data(id).num_samples = hdr.ctl(i).data(id).num_records * hdr.ctl(i).data(id).sample_rate * hdr.record_duration;
        case 2    % Newers NK systems: 1200
          % Channel order read in the extended blocks
          hdr.ctl(i).data(id).num_records = [];    % TODO: DON'T KNOW WHERE TO GET THIS FROM IN THE FILE
          hdr.ctl(i).data(id).num_samples = [];    % TODO: DON'T KNOW HOW TO COMPUTE THIS (NOW GUESSING IT FROM FILE SIZE)
      end
    end
  end
end

% Read information from additional blocks (newer systems)
switch (hdr.version)
  case 1    % Older NK systems: 1100, 2100
    % Not needed here, corresponding pointer is 0x0000 in the file
  case 2    % Newers NK systems: 1200
    % Only supported for one control block + one data block
    if (length(hdr.ctl) > 1) || (length(hdr.ctl(1).data) > 1)
      error(['This reader supports only recordings file with one data segment.' 10 ...
        'If you are interested in reading files with multiple data segments,' 10 ...
        'please contact us through the Brainstorm user forum.']);
    end
    
    % TODO: Probably needs a loop on control and data blocks here => Need example files
    i = 1;
    id = 1;
    
    % Reading the extended block address (2nd pointer)
    % (hdr.ext_address + 17) = UINT8 Number of blocks ?
    fseek(fid, hdr.ext_address + 18, 'bof');
    hdr.ctl(i).extblock2_address = fread(fid, 1, 'uint32');
    
    % Reading the extended block address (3rd pointer)
    % (hdr.ext_address2 + 17) = UINT8 Number of blocks ?
    fseek(fid, hdr.ctl(i).extblock2_address + 20, 'bof');
    hdr.ctl(i).data(id).extblock3_address = fread(fid, 1, 'uint32');
    
    % Suggestion from V. Gnatkovsky: not working with some of the files...
    %         % Read the block information: number of records
    %         fseek(fid, hdr.ctl(i).data(id).extblock3_address + 44, 'bof');
    %         hdr.ctl(i).data(id).num_records = fread(fid, 1, 'uint32');
    %         % Compute number of samples
    %         hdr.ctl(i).data(id).num_samples = hdr.ctl(i).data(id).num_records * hdr.ctl(i).data(id).sample_rate * hdr.record_duration;
    
    % Reading number of channels
    fseek(fid, hdr.ctl(i).data(id).extblock3_address + 68, 'bof');
    hdr.ctl(i).data(id).num_channels = fread(fid, 1, 'uint16') + 1;   % +1 for the STIM channel
    % Read channel order
    for iChan = 1:(hdr.ctl(i).data(id).num_channels - 1)  % -1 because the STIM channel is not listed here
      fseek(fid, hdr.ctl(i).data(id).extblock3_address + 72 + (iChan-1) * 10, 'bof');
      hdr.ctl(i).data(id).channel_list(iChan) = fread(fid, 1, 'uint16') + 1;
    end
    % Define pointer to the beginning of the recordings
    hdr.ctl(i).data(id).rec_address = hdr.ctl(i).data(id).extblock3_address + 72 + (hdr.ctl(i).data(id).num_channels - 1) * 10;   % -1 because the STIM channel is not in this list
end

% Get last position in the file
fseek(fid, 0, 'eof');
lastpos = ftell(fid);
% Close file
fclose(fid);


%% ===== GUESS FILE PROPERTIES =====
% TODO: Current limitation: allow only files with single control blocks
if (length(hdr.ctl) ~= 1)
  error(['Files with more than one control block are currently not supported.' 10 ...
    'Please post a message on the Brainstorm forum if you need this feature to be enabled.']);
end
% TODO: Current limitation: Multiple data blocks are not supported yet with the new file format (just need an example dataset)
if (length(hdr.ctl(1).data) > 1) && (hdr.version == 2)
  error(['Newer files with more than one data block are currently not supported yet (systems NK EEG-1200A V01.00).' 10 ...
    'Please post a message on the Brainstorm forum if you need this feature to be enabled.']);
end
% TODO: Current limitation: Multiple data blocks must have the same properties
if (length(hdr.ctl(1).data) > 1) && (...
    any([hdr.ctl(1).data.num_channels] ~= hdr.ctl(1).data(1).num_channels) || ...
    any([hdr.ctl(1).data.sample_rate] ~= hdr.ctl(1).data(1).sample_rate))
  error('Files with more than one data block must have the same number of channels and the same sampling rate.');
end
% Copy shared fields to the central header
hdr.sample_rate  = hdr.ctl(1).data(1).sample_rate;
hdr.num_channels = hdr.ctl(1).data(1).num_channels;


%% ===== READ LOG FILE =====
if ~isempty(LogFile)
  % Open file
  fid = fopen(LogFile, 'rb');
  if (fid == -1)
    error('Could not open LOG file');
  end
  % Get file signature
  device = fread(fid, [1 16], '*char');
  if (get_header_version(device) == 0)
    error(['LOG file has unknown signature: "' device '"']);
  end
  % Get log blocks
  fseek(fid, 145, 'bof');
  n_logblocks = fread(fid, 1, 'uint8');
  % Initializations
  total_logs = 0;
  
  % Loop on log blocks
  for i = 1:n_logblocks
    % Read number of logs in this block
    fseek(fid, 146 + ((i-1) * 20) , 'bof');
    logblock_address = fread(fid, 1, 'uint32');
    fseek(fid, logblock_address + 18, 'bof');
    n_logs = fread(fid, 1, 'uint8');
    % Initialization
    fseek(fid, logblock_address + 20, 'bof');
    hdr.logs(i).label = cell(1, n_logs);
    hdr.logs(i).time  = zeros(1, n_logs);
    % Read all the events
    for j = 1:n_logs
      hdr.logs(i).label{j} = str_clean(fread(fid, [1 20], '*char'));
      timeH = str2double(fread(fid, [1 2], '*char'));
      timeM = str2double(fread(fid, [1 2], '*char'));
      timeS = str2double(fread(fid, [1 2], '*char'));
      hdr.logs(i).time(j) = 60*60*timeH + 60*timeM + timeS;
      hdr.logs(i).label2{j} = fread(fid, [1 19], '*char');
      % Compute time stamp
      timeH = str2double(hdr.logs(i).label2{j}(8:9));
      timeM = str2double(hdr.logs(i).label2{j}(10:11));
      timeS = str2double(hdr.logs(i).label2{j}(12:13));
      hdr.logs(i).timestamp(j) = 60*60*timeH + 60*timeM + timeS;
    end
    
    % Read sub-events
    try
      % Read number of sub-logs
      fseek(fid, 146 + (((i-1) + 22) * 20) , 'bof');
      sublogblock_address = fread(fid, 1, 'uint32');
      fseek(fid, sublogblock_address + 18, 'bof');
      n_sublogs = fread(fid, 1, 'uint8');
      % Read sub-logs
      if (n_sublogs == n_logs)
        fseek(fid, sublogblock_address + 20, 'bof');
        for j = 1:n_logs
          hdr.logs(i).sublog{j} = fread(fid, [1 45], '*char');
          hdr.logs(i).time(j) = hdr.logs(i).time(j) + str2double(['0.' hdr.logs(i).sublog{j}(25:30)]);
        end
      end
    catch
      disp('NK> Could not read sub-events.');
    end
    total_logs = total_logs + n_logs;
  end
  % Close file
  fclose(fid);
else
  hdr.logs = [];
end


%% ===== CHANNELS: READ 21E FILE =====
% Read the channel names
ChannelMat = in_channel_nk(ElecFile, hdr.version);

% Gains are fixed for the list of channels:
%   - uV for channels: 1-42, 75, 76, 79-256, 257:1096 (new systems)
%   - mV for all the others
%   - Calibration = (Physical_max - Physical_min) ./ (Digital_max - Digital_min)
iChanMicro = [1:42, 75, 76, 79:256, 257:1096];
chanGains = 1e-3 * ones(1,1096) * ((12002.56+12002.9) / (32767 + 32768));
chanGains(iChanMicro) = 1e-6 * ((3199.902+3200) / (32767 + 32768));

% Keep only the channels saved in the file
iSelChannels = hdr.ctl(1).data(id).channel_list;
ChannelMat.Channel = ChannelMat.Channel(iSelChannels);
hdr.channel_gains  = chanGains(iSelChannels);

% Add last channel: markers/events
iChanStim = length(ChannelMat.Channel) + 1;
ChannelMat.Channel(iChanStim).Name    = 'Events';
ChannelMat.Channel(iChanStim).Type    = 'STIM';
hdr.channel_gains(iChanStim) = 1;

% Digital offset for the channel calibration (only the last one is a digital channel => no offset)
hdr.channel_digoffset = [32768 .* ones(1, length(ChannelMat.Channel)), 0];

% Make sure the names of the channels are unique
for i = length(ChannelMat.Channel):-1:2
  if ismember(ChannelMat.Channel(i).Name, {ChannelMat.Channel(1:i-1).Name})
    ChannelMat.Channel(i).Name = [ChannelMat.Channel(i).Name, '_', num2str(i)];
    ChannelMat.Channel(i).Type = 'MISC';
  end
end
% % Detect what is EEG or SEEG
% iTypeEeg = find(strcmpi({ChannelMat.Channel.Type}, 'EEG'));
% iNameEeg = find(ismember({ChannelMat.Channel.Name}, {'FP1', 'FP2', 'CZ', 'FCZ', 'PZ', 'OZ'}));
% if ~ismember({ChannelMat.Channel.Name}, 'F1')
%     iNameEeg = [iNameEeg, find(ismember({ChannelMat.Channel.Name}, {'F3', 'F4', 'F7', 'F8'}))];
% end
% if ~ismember({ChannelMat.Channel.Name}, 'C1')
%     iNameEeg = [iNameEeg, find(ismember({ChannelMat.Channel.Name}, {'C3', 'C4'}))];
% end
% if ~ismember({ChannelMat.Channel.Name}, 'P1')
%     iNameEeg = [iNameEeg, find(ismember({ChannelMat.Channel.Name}, {'P3', 'P4'}))];
% end
% if ~ismember({ChannelMat.Channel.Name}, 'O5')
%     iNameEeg = [iNameEeg, find(ismember({ChannelMat.Channel.Name}, {'O1', 'O2', 'O3', 'O4'}))];
% end
% if ~ismember({ChannelMat.Channel.Name}, 'T1')
%     iNameEeg = [iNameEeg, find(ismember({ChannelMat.Channel.Name}, {'T3', 'T4', 'T5', 'T6'}))];
% end
% % Mark all the other channels as SEEG
% iSeeg = setdiff(iTypeEeg, iNameEeg);
% [ChannelMat.Channel(iSeeg).Type] = deal('SEEG');


%% ===== READ PNT FILE =====
if ~isempty(PntFile)
  % Open file
  fid = fopen(PntFile, 'rb');
  if (fid == -1)
    error('Could not open LOG file');
  end
  % Get file signature
  device = fread(fid, [1 16], '*char');
  if (get_header_version(device) == 0)
    error(['PNT file has unknown signature: "' device '"']);
  end
  % Read patient info: Id
  fseek(fid, 1540, 'bof');
  hdr.patient.Id = str_clean(fread(fid, [1 10], '*char'));
  % Read patient info: Name
  fseek(fid, 1582, 'bof');
  hdr.patient.Name = str_clean(fread(fid, [1 20], '*char'));
  % Read patient info: Sex
  fseek(fid, 1610, 'bof');
  hdr.patient.Sex = str_clean(fread(fid, [1 6], '*char'));
  % Read patient info: Birthday
  fseek(fid, 1632, 'bof');
  hdr.patient.Birthday = fread(fid, [1 10], '*char');
  % Read recordings date
  fseek(fid, 64, 'bof');
  numDate = sscanf(fread(fid, [1 14], '*char'), '%04u%02u%02u%02u%02u%02u');
  hdr.startdate = sprintf('%02d/%02d/%04d', numDate(3), numDate(2), numDate(1));
  hdr.starttime = sprintf('%02d:%02d:%02d', numDate(4), numDate(5), numDate(6));
  % Close file
  fclose(fid);
end


%% ===== CREATE BRAINSTORM SFILE STRUCTURE =====
% Initialize returned file structure
sFile = db_template('sfile');
% Add information read from header
sFile.byteorder = 'n';
sFile.filename  = DataFile;
sFile.format    = 'EEG-NK';
sFile.device    = ['Nihon Kohden ' hdr.device];
sFile.comment   = fBase;
sFile.condition = [];
% Epochs
nEpochs = length(hdr.ctl(1).data);
sFile.epochs = repmat(db_template('epoch'), 1, nEpochs);
for i = 1:nEpochs
  % If the number of samples is not known (new format): guess it from the file or block size
  if isempty(hdr.ctl(1).data(i).num_samples)
    % There is a block after: use the address of the next block
    if (i < nEpochs)
      end_address = hdr.ctl(1).data(i+1).address - 1;
      % Last block: use the file size
    else
      end_address = lastpos;
    end
    % Compute from the
    hdr.ctl(1).data(i).num_samples = floor((end_address - hdr.ctl(1).data(i).rec_address) / hdr.num_channels / 2);  % /2 because we are counting int16 values
  end
  sFile.epochs(i).samples = [0, hdr.ctl(1).data(i).num_samples - 1];
  sFile.epochs(i).times   = sFile.epochs(i).samples ./ hdr.sample_rate;
  sFile.epochs(i).label   = sprintf('Block #%d', i);
  sFile.epochs(i).nAvg    = 1;
  sFile.epochs(i).select  = 1;
  sFile.epochs(i).bad     = 0;
  % Cumulated time of the begginning of the epoch
  epochLength(i) = hdr.ctl(1).data(i).num_samples ./ hdr.sample_rate;
end
cumTime = [0, cumsum(epochLength(1:end-1))];
% Consider that the sampling rate of the file is the sampling rate of the first signal
sFile.prop.sfreq   = hdr.sample_rate;
sFile.prop.samples = [min([sFile.epochs.samples]), max([sFile.epochs.samples])];
sFile.prop.times   = [min([sFile.epochs.times]),   max([sFile.epochs.times])];
sFile.prop.nAvg    = 1;
% No info on bad channels
sFile.channelflag = ones(hdr.num_channels,1);
% Save full header in the file link
sFile.header = hdr;
% Acquisition date
sFile.acq_date = str_date(hdr.startdate);


%% ===== EVENTS =====
if ~isempty(hdr.logs)
  % Get all the event types
  evtList = hdr.logs(1).label;
  % Events list
  [uniqueEvt, iUnique] = unique(evtList);
  uniqueEvt = evtList(sort(iUnique));
  % Initialize events list
  sFile.events = repmat(db_template('event'), 1, length(uniqueEvt));
  % Build events list
  for iEvt = 1:length(uniqueEvt)
    % Find all the occurrences of this event
    iOcc = find(strcmpi(uniqueEvt{iEvt}, evtList));
    % Concatenate all times
    t = hdr.logs(1).time(iOcc);
    % Detect epoch
    sFile.events(iEvt).epochs = 1 + 0*t(1,:);
    for k = 1:length(iOcc)
      % iEpoch = find(hdr.logs(1).timestamp(iOcc(k)) <= [hdr.ctl(1).data.timestamp, Inf], 1) - 1;
      iEpoch = find(t(k) >= cumTime, 1, 'last');
      if (iEpoch > 1)
        sFile.events(iEvt).epochs(k) = iEpoch;
        t(k) = t(k) - cumTime(iEpoch);
      end
    end
    % Set event
    sFile.events(iEvt).label   = str_clean(uniqueEvt{iEvt});
    sFile.events(iEvt).select  = 1;
    sFile.events(iEvt).times   = t;
    sFile.events(iEvt).samples = round(t .* sFile.prop.sfreq);
  end
end


%% ===== CHECK DEVICE =====
function ver = get_header_version(str)
% Older NK systems
if ismember(str, {...
    'EEG-1100A V01.00', ...
    'EEG-1100B V01.00', ...
    'EEG-1100C V01.00', ...
    'QI-403A   V01.00', ...
    'QI-403A   V02.00', ...
    'EEG-2100  V01.00', ...
    'EEG-2100  V02.00', ...
    'DAE-2100D V01.30', ...
    'DAE-2100D V02.00', ...
    'EEG-1100A V02.00', ...
    'EEG-1100B V02.00', ...
    'EEG-1100C V02.00'})
  ver = 1;
  
  % Newer NK systems (>= 2015)
elseif ismember(str, {...
    'EEG-1200A V01.00'})
  ver = 2;
  
else
  ver = 0;
end

%% ===== CLEAN STRINGS =====
function s = str_clean(s)
% Stop string at first termination
iNull = find(s == 0, 1);
if ~isempty(iNull)
  s(iNull:end) = [];
end
% Remove weird characters
s(~ismember(s, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-,:;.*+=?!<>''"`&%$()[]{}/\_@ ·¡‡¿‚¬‰ƒ„√Â≈Ê∆Á«È…Ë»Í ÎÀÌÕÏÃÓŒÔœÒ—Û”Ú“Ù‘ˆ÷ı’¯ÿúåﬂ˙⁄˘Ÿ˚€¸‹')) = [];
% Remove useless spaces
s = strtrim(s);


function filename = bst_fullfile(filename, varargin)
% BST_FILEPARTS: Same as Matlab's fullfile, but with much less tests.

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
%
% Copyright (c)2000-2018 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
%
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Francois Tadel, 2013

% Look for existing '\' in the filename
if any(filename == '\')
  sep = '\';
  otherSep = '/';
else
  sep = '/';
  otherSep = '\';
end
% Remove trailing separator
if isempty(filename)
  filename = '';
elseif (filename(end) == sep)
  filename = filename(1:end-1);
end
% Add all the inputs
for i = 1:length(varargin)
  p = varargin{i};
  % Empty: skip
  if isempty(p)
    continue;
  end
  % Replace with the correct separator
  p(p == otherSep) = sep;
  % If the new element starts with the separator: do not add an extra one
  if (p(1) == sep) || isempty(filename)
    filename = [filename p];
    % Add a separator between the base path and the new element
  else
    filename = [filename sep p];
  end
end


function varargout = bst_fileparts(filename, isFolder)
% BST_FILEPARTS: Same as Matlab's fileparts, but consider '\' as file separators on Linux/MacOS systems.

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
%
% Copyright (c)2000-2018 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
%
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Francois Tadel, 2010

% Parse inputs
if (nargin < 2) || isempty(isFolder)
  isFolder = 0;
end
% MacOS and Linux: Replace \ with /
if ~ispc
  filename(filename == '\') = '/';
end
% Check if link
if (length(filename) > 5) && strcmpi(filename(1:5), 'link|')
  if (nargout >= 1)
    varargout{1} = 'link';
  end
  if (nargout >= 2)
    varargout{2} = filename;
  end
  if (nargout >= 3)
    varargout{3} = [];
  end
  % Folder: split only with str_split
elseif isFolder
  % Replace dots with invalid characters, to avoid splitting the folder names that include dots
  filename = strrep(filename, '.', '>');
  % Split filename
  [varargout{1:nargout}] = fileparts(filename);
  % Restore the dots
  for i = 1:length(varargout)
    varargout{i} = strrep(varargout{i}, '>', '.');
  end
  % Regular file
else
  [varargout{1:nargout}] = fileparts(filename);
end


function isExist = file_exist(filename)
% FILE_EXIST: Test the existence of an absolute file path on the disk.
%             Replacement for the Matlab call "exist(..., 'file')" that gives unexpected results
%             when the file is somewhere in the Matlab path.

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
%
% Copyright (c)2000-2018 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
%
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Author: Francois Tadel, 2011-2013

% Empty variable
if isempty(filename)
  isExist = 0;
  % File is a root folder: let's consider it exists
  % elseif strcmp(filename, bst_fileparts(filename))
elseif isequal(filename, '/') || isequal(filename, '\')
  isExist = 1;
  % File does not exist: no ambiguity
elseif isempty(dir(filename))
  isExist = 0;
  % File exists: we have to make sure it is NOT relatively to the current path
else
  % Check the file relative to the current Matlab folder
  pwdPath = pwd;
  pwdFile = [pwdPath '/' filename];
  % If it does NOT exist: no ambiguity, file exists
  if isempty(dir(pwdFile))
    isExist = 1;
    % Else: we consider that the file exists only in the current folder is a root folder
    % (=> folder = folder's parent)
  elseif strcmp(pwdPath, bst_fileparts(pwdPath, 1))
    isExist = 1;
  else
    isExist = 0;
  end
end


function ChannelMat = in_channel_nk(ChannelFile, version)
% IN_CHANNEL_NK:  Read channel names from a Nihon Kohden 21E file.
%
% USAGE:  ChannelMat = in_channel_nk(ChannelFile, version=2)
%         ChannelMat = in_channel_nk()             : Return default channel names

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
%
% Copyright (c)2000-2018 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
%
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Francois Tadel, 2017

%% ===== PARSE INPUTS =====
if (nargin < 2) || isempty(version)
  version = 2;
end


%% ===== DEFAULTS =====
% Default number of channels changes based on the header format
switch (version)
  case 1,  Nchan = 256;
  case 2,  Nchan = 1096;
end
% Initialize output channel structure
ChannelMat = db_template('channelmat');
ChannelMat.Comment = 'Nihon Kohden';

ChannelMat.Channel = repmat(db_template('channeldesc'), 1, Nchan);

% Default electrode labels
for i = 1:length(ChannelMat.Channel)
  switch (i)
    case 1,    ChannelMat.Channel(i).Name = 'FP1';                       ChannelMat.Channel(i).Type = 'EEG';
    case 2,    ChannelMat.Channel(i).Name = 'FP2';                       ChannelMat.Channel(i).Type = 'EEG';
    case 3,    ChannelMat.Channel(i).Name = 'F3';                        ChannelMat.Channel(i).Type = 'EEG';
    case 4,    ChannelMat.Channel(i).Name = 'F4';                        ChannelMat.Channel(i).Type = 'EEG';
    case 5,    ChannelMat.Channel(i).Name = 'C3';                        ChannelMat.Channel(i).Type = 'EEG';
    case 6,    ChannelMat.Channel(i).Name = 'C4';                        ChannelMat.Channel(i).Type = 'EEG';
    case 7,    ChannelMat.Channel(i).Name = 'P3';                        ChannelMat.Channel(i).Type = 'EEG';
    case 8,    ChannelMat.Channel(i).Name = 'P4';                        ChannelMat.Channel(i).Type = 'EEG';
    case 9,    ChannelMat.Channel(i).Name = 'O1';                        ChannelMat.Channel(i).Type = 'EEG';
    case 10,   ChannelMat.Channel(i).Name = 'O2';                        ChannelMat.Channel(i).Type = 'EEG';
    case 11,   ChannelMat.Channel(i).Name = 'F7';                        ChannelMat.Channel(i).Type = 'EEG';
    case 12,   ChannelMat.Channel(i).Name = 'F8';                        ChannelMat.Channel(i).Type = 'EEG';
    case 13,   ChannelMat.Channel(i).Name = 'T3';                        ChannelMat.Channel(i).Type = 'EEG';
    case 14,   ChannelMat.Channel(i).Name = 'T4';                        ChannelMat.Channel(i).Type = 'EEG';
    case 15,   ChannelMat.Channel(i).Name = 'T5';                        ChannelMat.Channel(i).Type = 'EEG';
    case 16,   ChannelMat.Channel(i).Name = 'T6';                        ChannelMat.Channel(i).Type = 'EEG';
    case 17,   ChannelMat.Channel(i).Name = 'FZ';                        ChannelMat.Channel(i).Type = 'EEG';
    case 18,   ChannelMat.Channel(i).Name = 'CZ';                        ChannelMat.Channel(i).Type = 'EEG';
    case 19,   ChannelMat.Channel(i).Name = 'PZ';                        ChannelMat.Channel(i).Type = 'EEG';
    case 20,   ChannelMat.Channel(i).Name = 'E';                         ChannelMat.Channel(i).Type = 'MISC';
    case 21,   ChannelMat.Channel(i).Name = 'PG1';                       ChannelMat.Channel(i).Type = 'EEG';
    case 22,   ChannelMat.Channel(i).Name = 'PG2';                       ChannelMat.Channel(i).Type = 'EEG';
    case 23,   ChannelMat.Channel(i).Name = 'A1';                        ChannelMat.Channel(i).Type = 'EEG';
    case 24,   ChannelMat.Channel(i).Name = 'A2';                        ChannelMat.Channel(i).Type = 'EEG';
    case 25,   ChannelMat.Channel(i).Name = 'T1';                        ChannelMat.Channel(i).Type = 'EEG';
    case 26,   ChannelMat.Channel(i).Name = 'T2';                        ChannelMat.Channel(i).Type = 'EEG';
    case num2cell(27:37), ChannelMat.Channel(i).Name = sprintf('X%d', i - 26);     ChannelMat.Channel(i).Type = 'EEG';
    case 38,   ChannelMat.Channel(i).Name = 'BN';                        ChannelMat.Channel(i).Type = 'MISC';
    case 39,   ChannelMat.Channel(i).Name = 'AV';                        ChannelMat.Channel(i).Type = 'MISC';
    case 40,   ChannelMat.Channel(i).Name = 'SD';                        ChannelMat.Channel(i).Type = 'MISC';
    case 41,   ChannelMat.Channel(i).Name = 'Aav';                       ChannelMat.Channel(i).Type = 'MISC';
    case 42,   ChannelMat.Channel(i).Name = '0V';                        ChannelMat.Channel(i).Type = 'MISC';
    case num2cell(43:70), ChannelMat.Channel(i).Name = sprintf('DC%02d', i - 42);  ChannelMat.Channel(i).Type = 'DC';
    case 71,   ChannelMat.Channel(i).Name = 'SpO2';                      ChannelMat.Channel(i).Type = 'MISC';
    case 72,   ChannelMat.Channel(i).Name = 'EtCO2';                     ChannelMat.Channel(i).Type = 'MISC';
    case 73,   ChannelMat.Channel(i).Name = 'Pulse';                     ChannelMat.Channel(i).Type = 'MISC';
    case 74,   ChannelMat.Channel(i).Name = 'CO2Wave';                   ChannelMat.Channel(i).Type = 'MISC';
    case 75,   ChannelMat.Channel(i).Name = 'BN1';                       ChannelMat.Channel(i).Type = 'EEG';
    case 76,   ChannelMat.Channel(i).Name = 'BN2';                       ChannelMat.Channel(i).Type = 'EEG';
    case 77,   ChannelMat.Channel(i).Name = 'Mark1';                     ChannelMat.Channel(i).Type = 'MISC';
    case 78,   ChannelMat.Channel(i).Name = 'Mark2';                     ChannelMat.Channel(i).Type = 'MISC';
    case num2cell(79:93),  ChannelMat.Channel(i).Name = sprintf('U%d',i); ChannelMat.Channel(i).Type = 'UNKNOWN';
    case 94,   ChannelMat.Channel(i).Name = 'RFU1';                      ChannelMat.Channel(i).Type = 'MISC';
    case 95,   ChannelMat.Channel(i).Name = 'RFU2';                      ChannelMat.Channel(i).Type = 'MISC';
    case 96,   ChannelMat.Channel(i).Name = 'RFU3';                      ChannelMat.Channel(i).Type = 'MISC';
    case 97,   ChannelMat.Channel(i).Name = 'RFU4';                      ChannelMat.Channel(i).Type = 'MISC';
    case 98,   ChannelMat.Channel(i).Name = 'RFU5';                      ChannelMat.Channel(i).Type = 'MISC';
    case 99,   ChannelMat.Channel(i).Name = 'RFU6';                      ChannelMat.Channel(i).Type = 'MISC';
    case 100,  ChannelMat.Channel(i).Name = 'COM';                       ChannelMat.Channel(i).Type = 'MISC';
    case 101,  ChannelMat.Channel(i).Name = 'X12/BP1';                   ChannelMat.Channel(i).Type = 'EEG';
    case 102,  ChannelMat.Channel(i).Name = 'X13/BP2';                   ChannelMat.Channel(i).Type = 'EEG';
    case 103,  ChannelMat.Channel(i).Name = 'X14/BP3';                   ChannelMat.Channel(i).Type = 'EEG';
    case 104,  ChannelMat.Channel(i).Name = 'X15/BP4';                   ChannelMat.Channel(i).Type = 'EEG';
    case num2cell(105:255), ChannelMat.Channel(i).Name = sprintf('X%d', i - 89);   ChannelMat.Channel(i).Type = 'EEG';
    case 255,  ChannelMat.Channel(i).Name = 'AVG';                       ChannelMat.Channel(i).Type = 'MISC';
    case 256,  ChannelMat.Channel(i).Name = 'Z';                         ChannelMat.Channel(i).Type = 'MISC';
    case num2cell(257:Nchan),  ChannelMat.Channel(i).Name = sprintf('EX%d', i);   ChannelMat.Channel(i).Type = 'EEG';
  end
end

% If only the defaults are needed
if (nargin == 0) || isempty(ChannelFile)
  return;
end


%% ===== READ 21E FILE =====
% Open file
fid = fopen(ChannelFile, 'r');
if (fid == -1)
  error('Cannot open file.');
end

% Initialize indices structure
curBlock = '';
% Read file line by line
while 1
  % Read line
  read_line = fgetl(fid);
  % Empty line: go to next line
  if isempty(read_line)
    continue
    % End of file: stop reading
  elseif (read_line(1) == -1)
    break
  end
  % Strip additional spaces
  read_line = strtrim(read_line);
  % Empty line or comment: go to next line
  if isempty(read_line) || (read_line(1) == '#')
    curBlock = '';
    continue
  end
  % Check if beginning/end of block
  if strcmpi(read_line, '[ELECTRODE]')
    curBlock = 'electrode';
  elseif strcmpi(read_line, '[REFERENCE]')
    curBlock = 'reference';
  elseif strcmpi(read_line, '[SYSTEM_SETUP]')
    curBlock = 'setup';
  elseif strcmpi(read_line(1), '[')
    curBlock = 'skip';
  else
    switch (curBlock)
      case 'electrode'
        if any(read_line == '=')
          % Split line around "="
          splitLine = str_split(read_line, '=');
          if (length(splitLine) ~= 2)
            continue;
          end
          % Read fields
          iChannel = str2num(splitLine{1}) + 1;
          chName   = strtrim(splitLine{2});
          % Save channel name
          if ~isempty(chName)
            ChannelMat.Channel(iChannel).Name = chName;
            % Look for some special names
            if strcmpi(chName, 'E') && (iChannel ~= 20)
              ChannelMat.Channel(iChannel).Name = 'E_KG';
              ChannelMat.Channel(iChannel).Type = 'ECG';
            elseif strcmpi(chName, 'KG')
              ChannelMat.Channel(iChannel).Type = 'ECG';
            elseif ismember(ChannelMat.Channel(iChannel).Name, {'0','1','L','R','DEL1','DEL2','DEL3','DEL4','MILO1','MILO2'})
              ChannelMat.Channel(iChannel).Type = 'MISC';
            elseif (length(ChannelMat.Channel(iChannel).Name) >= 2) && ismember(ChannelMat.Channel(iChannel).Name(1:2), {'D0','D1','D2','D3','D4','D5','D6','D7','D8','D9'})
              ChannelMat.Channel(iChannel).Type = 'MISC';
            end
          end
        end
      case 'reference'
        if any(read_line == '=')
          % Split line around "="
          splitLine = str_split(read_line, '=');
          if (length(splitLine) ~= 2)
            continue;
          end
          % Read fields
          iChannel = str2num(splitLine{1}) + 1;
          chRef    = strtrim(splitLine{2});
          chRef(chRef == '$') = [];
          % Save channel name
          if ~isempty(chRef)
            ChannelMat.Channel(iChannel).Comment = ['Reference: ' chRef];
          end
        end
    end
  end
end
% Close file
fclose(fid);


function [ template ] = db_template(structureName)
% DB_TEMPLATE: Defines a template structure for all the Brainstorm data types.
%
% USAGE :  [template] = db_template(structureName);

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
%
% Copyright (c)2000-2018 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
%
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Francois Tadel, 2008-2018


switch lower(structureName)
  % ===== BASIC LOADED STRUCTURES =====
  case 'anatomy'
    template = struct('Comment',  '', ...
      'FileName', '');
  case 'surface'
    template = struct('Comment',     '', ...
      'FileName',    '', ...
      'SurfaceType', '');
  case 'channel'
    template = struct('FileName',        '', ...
      'Comment',         '', ...
      'nbChannels',      0, ...
      'Modalities',      [], ...
      'DisplayableSensorTypes', []);
  case 'data'
    template = struct('FileName',       '', ...
      'Comment',        '', ...
      'DataType',       'recordings', ...
      'BadTrial',       0);
  case 'dipoles'
    template = struct('FileName',       '', ...
      'Comment',        '', ...
      'DataFile',       '');
  case 'headmodel'
    template = struct('FileName',       '', ...
      'HeadModelType',  '', ...
      'MEGMethod',      '', ...
      'EEGMethod',      '', ...
      'Comment',        '', ...
      'ECOGMethod',     '', ...
      'SEEGMethod',     '');
  case 'results'
    template = struct('FileName',       '', ...
      'Comment',        '', ...
      'DataFile',       '', ...
      'isLink',         0, ...
      'HeadModelType',  '');
  case 'stat'
    template = struct('FileName',       '', ...
      'Comment',        '', ...
      'Type',           '', ...
      'pThreshold',     '', ...
      'DataFile',       '');
  case 'timefreq'
    template = struct('FileName',       '', ...
      'Comment',        '', ...
      'DataFile',       '', ...
      'DataType',       '');
  case 'image'
    template = struct('FileName',       '', ...
      'Comment',        '');
  case 'matrix'
    template = struct('FileName',       '', ...
      'Comment',        '');
  case {'noisecov', 'ndatacov'}
    template = struct('FileName',       '', ...
      'Comment',        '');
    
    % ==== FILES ====
  case 'mrimat'
    template = struct(...
      'Comment',     '', ...
      'Cube',        [], ...
      'Voxsize',     [], ...
      'NCS',         [], ...
      'SCS',         [], ...
      'Header',      [], ...
      'Histogram',   [], ...
      'InitTransf',  [], ...
      'History',     []);
    
  case 'surfacemat'
    template = struct(...
      'Comment',         '', ...
      'Vertices',        [], ...
      'Faces',           [], ...
      'VertConn',        [], ...
      'VertNormals',     [], ...
      'Curvature',       [], ...
      'SulciMap',        [], ...
      'Atlas',           db_template('Atlas'), ...
      'iAtlas',          1, ...
      'tess2mri_interp', [], ...
      'Reg',             [], ...
      'History',         []);
    
  case 'datamat'
    template = struct('F',            [], ...
      'Std',          [], ...
      'Comment',      '', ...
      'ChannelFlag',  [], ...
      'Time',         [], ...
      'DataType',     'recordings', ...
      'Device',       '', ...
      'nAvg',         1, ...
      'Events',       repmat(db_template('event'), 0), ...
      'ColormapType', [], ...
      'DisplayUnits', [], ...
      'History',      []);
  case 'noisecovmat'
    template = struct('NoiseCov',     [], ...
      'Comment',      '', ...
      'nSamples',     [], ...
      'FourthMoment', [], ...
      'History',      []);
  case 'headmodelmat'
    template = struct('MEGMethod',     [], ...
      'EEGMethod',     [], ...
      'ECOGMethod',    [], ...
      'SEEGMethod',    [], ...
      'Gain',          [], ...
      'Comment',       '', ...  [nChannel, 3*nSources]
      'HeadModelType', '', ...  {'volume', 'surface'}
      'GridLoc',       [], ...  [nSources, 3]
      'GridOrient',    [], ...  [nSources, 3]
      'GridAtlas',     [], ...
      'GridOptions',   [], ...
      'SurfaceFile',   '', ...
      'Param',         []);
  case 'resultsmat'
    template = struct('ImagingKernel', [], ...
      'ImageGridAmp',  [], ...
      'Std',           [], ...
      'Whitener',      [], ...
      'SourceDecompSa',[], ...
      'SourceDecompVa',[], ...
      'nComponents',   1, ...
      'Comment',       '', ...
      'Function',      '', ...
      'Time',          [], ...
      'DataFile',      '', ...
      'HeadModelFile', '', ...
      'HeadModelType', 'surface', ...
      'ChannelFlag',   [], ...
      'GoodChannel',   [], ...
      'SurfaceFile',   [], ...
      'Atlas',         [], ...
      'GridLoc',       [], ...
      'GridOrient',    [], ...
      'GridAtlas',     [], ...
      'Options',       [], ...
      'ColormapType',  [], ...
      'DisplayUnits',  [], ...
      'ZScore',        [], ...
      'nAvg',          [], ...
      'History',       []);
  case 'timefreqmat'
    template = struct('TF',          [], ...
      'TFmask',      [], ...
      'Std',         [], ...
      'Comment',     '', ...
      'DataType',    '', ...
      'Time',        [], ...
      'TimeBands',   [], ...
      'Freqs',       [], ...
      'RefRowNames', [], ...
      'RowNames',    [], ...
      'Measure',     [], ...
      'Method',      [], ...
      'DataFile',    '', ...
      'SurfaceFile', [], ...
      'GridLoc',     [], ...
      'GridAtlas',   [], ...
      'Atlas',       [], ...
      'HeadModelFile', [], ...
      'HeadModelType', [], ...
      'nAvg',        1, ...
      'ColormapType',[], ...
      'DisplayUnits',[], ...
      'Options',     [], ...
      'History',     []);
  case 'channelmat'
    template = struct(...
      'Comment',    'Channels', ...
      'MegRefCoef', [], ...   % CTF compensators matrix, [nMeg x nMegRef]
      'Projector',  [], ...   % SSP matrix, [nChannels x nChannels]
      'TransfMeg',  [], ...   % MEG sensors: Successive transforms from device coord. system to brainstorm SCS
      'TransfMegLabels', [], ... % Labels for each MEG transformation
      'TransfEeg',  [], ...   % EEG sensors: Successive transforms from device coord. system to brainstorm SCS
      'TransfEegLabels', [], ... % Labels for each EEG transformation
      'HeadPoints', struct(...% Digitized head points
      'Loc',    [], ...
      'Label',  [], ...
      'Type',   []), ...
      'Channel',    [], ...  % [nChannels] Structure array, one structure per sensor
      'IntraElectrodes', [], ...
      'History',     []);
    
  case 'dipolemat'
    template = struct(...
      'Comment',     '', ...
      'Time',        [], ...
      'DipoleNames', [], ...
      'Subset',      [], ...
      'Dipole',      repmat(struct(...
      'Index',         0, ...
      'Time',          0, ...
      'Origin',        [0 0 0], ...
      'Loc',           [0 0 0], ...
      'Amplitude',     [0 0 0], ...
      'Goodness',      [], ...
      'Errors',        0, ...
      'Noise',         0, ...
      'SingleError',   [0 0 0 0 0], ...
      'ErrorMatrix',   zeros(1,25), ...
      'ConfVol',       [], ...
      'Khi2',          [], ...
      'DOF',           [], ...
      'Probability',   0, ...
      'NoiseEstimate', 0, ...
      'Perform',       0), 0), ...
      'DataFile', '', ...
      'Options',  [], ...
      'History',  []);
    
  case 'projector'
    template = struct(...
      'Comment',      [], ...
      'Components',   [], ...
      'CompMask',     [], ...
      'Status',       0, ...  % 0: not applied; 1: applied on the fly; 2: saved in the file, not revertible : ADDITIONAL VALUES = EEG REFERENCES
      'SingVal',      []);
    
  case 'matrixmat'
    template = struct(...
      'Value',       [], ...
      'Std',         [], ...
      'Comment',     '', ...
      'Description', [], ...
      'Time',        [], ...
      'ChannelFlag', [], ...
      'nAvg',        1, ...
      'Events',      repmat(db_template('event'), 0), ...
      'SurfaceFile', [], ...
      'Atlas',       [], ...
      'DisplayUnits',[], ...
      'History',     []);
  case 'statmat'
    template = struct(...
      'pmap',          [], ...
      'tmap',          [], ...
      'df',            0, ...
      'SPM',           [], ...
      'Correction',    'no', ...
      'Type',          '', ...
      'Comment',       '', ...
      'Time',          [], ...
      'ChannelFlag',   [], ...
      ... % Results fields
      'HeadModelType', [], ...
      'SurfaceFile',   [], ...
      'nComponents',   [], ...
      'Atlas',         [], ...
      'GridLoc',       [], ...
      'GridOrient',    [], ...
      'GridAtlas',     [], ...
      'GoodChannel',   [], ...
      'ColormapType',  '', ...
      'DisplayUnits',  [], ...
      'History',       [], ...
      ... % Matrix fields
      'Description',   [], ...
      ... % Timefreq fields
      'TFmask',        [], ...
      'DataType',      [], ...
      'Freqs',         [], ...
      'Method',        [], ...
      'Options',       [], ...
      'RefRowNames',   [], ...
      'RowNames',      [], ...
      'TimeBands',     [], ...
      'Measure',       [], ...
      'StatClusters',  []);
    
    % ==== SUBJECT ====
  case 'subjectmat'
    template = struct(...
      'Comments',    '', ...
      'Anatomy',     '', ...
      'Cortex',      '', ...
      'Scalp',       '', ...
      'InnerSkull',  '', ...
      'OuterSkull',  '', ...
      'UseDefaultAnat',    0, ...
      'UseDefaultChannel', 1);
  case 'subject'
    template = struct(...
      'Name',                'Unnamed', ...
      'Comments',            '', ...
      'FileName',            '', ...
      'DateOfAcquisition',   '', ...
      'Anatomy',             repmat(db_template('Anatomy'),0), ...
      'Surface',             repmat(db_template('Surface'),0), ...
      'iAnatomy',            [], ...
      'iScalp',              [], ...
      'iCortex',             [], ...
      'iInnerSkull',         [], ...
      'iOuterSkull',         [], ...
      'iOther',              [], ...
      'UseDefaultAnat',      0 , ...
      'UseDefaultChannel',   1);
    
    % ==== STUDY ====
  case 'studymat'
    template = struct(...
      'DateOfStudy', date, ...
      'Name',        'Unnamed', ...
      'BadTrials',   []);
  case 'study'
    template = struct(...
      'Name',                'Unnamed', ...
      'FileName',            '', ...
      'DateOfStudy',         '', ...
      'BrainStormSubject',   '', ...
      'Condition',           '', ...
      ... repmat(db_template('Channel'),0)
      'Channel',             struct(...
      'FileName',        {}, ...
      'Comment',         {}, ...
      'nbChannels',      {}, ...
      'Modalities' ,     {}, ...
      'DisplayableSensorTypes', {}), ...
      'iChannel',            [], ...
      ... repmat(db_template('Data'),0)
      'Data',              struct(...
      'FileName',        {}, ...
      'Comment',         {}, ...
      'DataType',        {}, ...
      'BadTrial',        {}), ...
      ... repmat(db_template('HeadModel'),0)
      'HeadModel',         struct(...
      'FileName',         {}, ...
      'HeadModelType',    {}, ...
      'MEGMethod',        {}, ...
      'EEGMethod',        {}, ...
      'Comment',          {}, ...
      'ECOGMethod',       {}, ...
      'SEEGMethod',       {}), ...
      'iHeadModel',        [], ...
      ... repmat(db_template('Results'),0)
      'Result',              struct(...
      'FileName',        {}, ...
      'Comment',         {}, ...
      'DataFile',        {}, ...
      'isLink',          {}, ...
      'HeadModelType',   {}), ...
      ... repmat(db_template('Stat'),  0)
      'Stat',                struct(...
      'FileName',        {}, ...
      'Comment',         {}, ...
      'Type',            {}, ...
      'pThreshold',      {}, ...
      'DataFile',        {}), ...
      ... repmat(db_template('Image'),  0)
      'Image',               struct(...
      'FileName',        {}, ...
      'Comment',         {}), ...
      ... repmat(db_template('noiseCov'), 0)
      'NoiseCov',            struct(...
      'FileName',        {}, ...
      'Comment',         {}), ...
      ... repmat(db_template('Dipoles'), 0)
      'Dipoles',             struct(...
      'FileName',        {}, ...
      'Comment',         {}, ...
      'DataFile',        {}), ...
      ... repmat(db_template('Timefreq'),  0)
      'Timefreq',            struct(...
      'FileName',        {}, ...
      'Comment',         {}, ...
      'DataFile',        {}, ...
      'DataType',        {}), ...
      ... repmat(db_template('Matrix'),  0)
      'Matrix',             struct(...
      'FileName',        {}, ...
      'Comment',         {}));
    
    % ==== PROTOCOLINFO ====
  case 'protocolinfo'
    template = struct(...
      'Comment',               'default_protocol', ...
      'STUDIES',               '', ...
      'SUBJECTS',              '', ...
      'iStudy',                [], ...
      'UseDefaultAnat',        0, ...
      'UseDefaultChannel',     1);
    
  case 'protocolsubjects'
    template = struct(...
      'Subject',        repmat(db_template('Subject'), 0), ...
      'DefaultSubject', []);
    
  case 'protocolstudies'
    template = struct(...
      'Study',         repmat(db_template('Study'), 0), ...
      'DefaultStudy',  db_template('Study'), ...
      'AnalysisStudy', db_template('Study'));
    
    % ==== LAYOUT ====
  case 'layout'
    template = struct(...
      'MainWindowPos',   [0 0 0 0], ...
      'ExplorationMode', 'Subjects', ...
      'WindowManager',   'TileWindows', ...  % {'WeightWindows', 'TileWindows', 'FullArea', 'FullScreen', 'None'}
      'UserSetups',      [], ...
      'DoubleScreen',    1, ...
      'FullScreen',      0);
    
    % ==== EVENT ====
  case 'event'
    template = struct(...
      'label',      '', ...
      'color',      [], ...
      'epochs',     [], ...      % [list of epochs indices]
      'samples',    [], ...      % [list of time indices]
      'times',      [], ...      % [list of time values]
      'reactTimes', [], ...      % [list of reaction times, when applicable]
      'select',     1);
    
    % ==== EPOCH ====
  case 'epoch'
    template = struct(...
      'label',   '', ...
      'samples', [], ...        % [iStart, iStop]
      'times',   [], ...        % [tStart, tStop]
      'nAvg',    1, ...         % Number of epochs averaged to produce this block
      'select',  1, ...
      'bad',     0, ...
      'channelflag', []);
    
    % ==== FILE IMPORT ====
  case 'sfile'
    template = struct(...
      'filename',   '', ...  % Full path to the file
      'format',     '', ...  % {fif,ctf,egi,neuroscan,brainamp,lena,cartool,...}
      'device',     '', ...  % {neuromag,ctf,egi,neuroscan,brainamp,...}
      'condition',  '', ...
      'comment',    '', ...
      'byteorder',  '', ...  % ieee-le, ieee-be...
      'prop', struct(...            % Properties of the recordings
      'times',        [], ...   % [tStart, tStop]
      'samples',      [], ...   % [iStart, iStop]
      'sfreq',        0, ...    % Sampling frequency
      'nAvg',         1, ...    % Number of trials used to create this file
      'currCtfComp',  [], ...   % {0,1,3} Current CTF compensation order already applied to the recordings
      'destCtfComp',  []), ...  % {0,1,3} Destination CTF compensation order
      'epochs',      repmat(db_template('epoch'), 0), ...
      'events',      repmat(db_template('event'), 0), ...
      'header',      [], ...
      'channelflag', [], ...
      'acq_date',    []);
    
  case 'importoptions'
    template = struct(...
      'ImportMode',       'Epoch', ...           % Import mode:  {Epoch, Time, Event}
      'UseEvents',        0, ...                 % {0,1}: If 1, perform epoching around the selected events
      'TimeRange',        [], ...                % Specifying a time window for 'Time' import mode
      'EventsTimeRange',  [-0.1000 0.3000], ...  % Time range for epoching, zero is the event onset (if epoching is enabled)
      'GetAllEpochs',     0, ...                 % {0,1}: Import all arrays, no matter how many they are
      'iEpochs',          1, ...                 % Array of indices of epochs to import (if GetAllEpochs is not enabled)
      'SplitRaw',         0, ...                 % {0,1}: If 1, and if importing continuous recordings (no epoching, no events): split recordings in small time blocks
      'SplitLength',      2, ...                 % Duration of each split time block, in seconds
      'Resample',         0, ...                 % Enable resampling (requires Signal Processing Toolbox)
      'ResampleFreq',     0, ...                 % Resampling frequency (if resampling is enabled)
      'UseCtfComp',       1, ...                 % Get and apply CTF 3rd gradient correction if available
      'UseSsp',           1, ...                 % Get and apply SSP (Signal Space Projection) vectors if available
      'RemoveBaseline',   'no', ...              % Method used to remove baseline of each channel: {no, all, time, sample}
      'BaselineRange',    [], ...                % [tStart,tStop] If RemoveBaseline is 'time'; Else ignored
      'events',           [], ...                % Events structure: (label, epochs, samples, times, reactTimes, select)
      'CreateConditions', 0, ...                 % {0,1} If 1, create new conditions in Brainstorm database if it is more convenient
      'ChannelReplace',   1, ...        % If 1, prompts for automatic replacement of an existing channel file. If 2, replace it automatically. If 0, do not do it.
      'ChannelAlign',     1, ...        % If 1, prompts for automatic registration. If 2, perform it automatically. If 0, do not do it.
      'IgnoreShortEpochs',1, ...        % If 1, prompts for ignoring the epochs that are shorter that the others. If 2, ignore them automatically. If 0, do not do it.
      'EventsMode',       'ask', ...    % Where to get the events from: {'ask', 'ignore', Filename, ChannelName, ChannelNames}
      'EventsTrackMode',  'ask', ...    % {'value','bit','ttl','rttl','ask'}
      'EventsTypes',      '', ...       % String with a list of eventtypes to use to group the epochs (EEGLAB only)
      'DisplayMessages',  1);           % If 0, do not show any of the message boxes that the user would normally see
    
    % ==== COLORMAPS ====
  case 'colormap'
    template = struct(...
      'Name',             '', ...
      'CMap',             [], ...
      'isAbsoluteValues', 0, ...
      'isRealMin',        0, ...
      'DisplayColorbar',  1, ...
      'MaxMode',          'global', ...
      'MinValue',         [], ...
      'MaxValue',         [], ...
      'Contrast',         0, ...
      'Brightness',        0);
    
  case 'colormapinfo'
    template.AllTypes     = {};
    template.Type         = '';
    template.DisplayUnits = '';
    
    % ==== GLOBAL DATA ====
  case 'measures'
    template = struct(...
      'DataType',        [], ...
      'F',               [], ...
      'Std',             [], ...
      'Time',            [], ...
      'SamplingRate',    [], ...
      'NumberOfSamples', [], ...
      'ChannelFlag',     [], ...
      'sFile',           [], ...
      'isModified',      0, ...
      'isFiltered',      0, ...
      'ColormapType',    '', ...
      'DisplayUnits',    [], ...
      'StatClusters',    []);
    
  case 'loadedresults'
    template = struct(...
      'FileName',         '', ...
      'DataType',         '', ...
      'Comment',          '', ...
      'Time',             [], ...
      'SamplingRate',     [], ...
      'NumberOfSamples',  [], ...
      'ChannelFlag',      [], ...
      'ImageGridAmp',     [], ...
      'ImagingKernel',    [], ...
      'Std',              [], ...
      'ZScore',           [], ...
      'SurfaceFile',      [], ...
      'HeadModelType',    [], ...
      'HeadModelFile',    [], ...
      'GridLoc',          [], ...
      'GridOrient',       [], ...
      'GridAtlas',        [], ...
      'grid2mri_interp',  [], ...
      'nComponents',      1, ...
      'GoodChannel',      [], ...
      'OpticalFlow',      [], ...
      'ColormapType',     '', ...
      'DisplayUnits',     [], ...
      'Atlas',            [], ...
      'StatClusters',     []);
    
  case 'loadeddipoles'
    template = struct(...
      'FileName',         '', ...
      'Comment',          '', ...
      'DataFile',         '', ...
      'Time',             [], ...
      'SamplingRate',     [], ...
      'NumberOfSamples',  [], ...
      'DipoleNames',      [], ...
      'Dipole',           [], ...
      'DisplayUnits',     [], ...
      'Subset',           [], ...
      'PreferredTimes',   []);
    
  case 'loadedtimefreq'
    template = struct(...
      'FileName',         '', ...
      'Comment',          '', ...
      'DataFile',         '', ...
      'DataType',         '', ...
      'TF',               [], ...
      'TFmask',           [], ...
      'Freqs',            [], ...
      'Time',             [], ...
      'TimeBands',        [], ...
      'SamplingRate',     [], ...
      'NumberOfSamples',  [], ...
      'RefRowNames',      [], ...
      'RowNames',         [], ...
      'Modality',         [], ...
      'AllModalities',    [], ...
      'Measure',          [], ...
      'Method',           [], ...
      'Options',          [], ...
      'ColormapType',     '', ...
      'DisplayUnits',     [], ...
      'Atlas',            [], ...
      'GridLoc',          [], ...
      'GridAtlas',        [], ...
      'SurfaceFile',      [], ...
      'sPAC',             [], ...
      'StatClusters',     []);
    
  case 'loadedmatrix'
    template = struct(...
      'FileName',     '', ...
      'Comment',      '', ...
      'Description',  [], ...
      'DisplayUnits',     [], ...
      'SurfaceFile',  '', ...
      'Atlas',        [], ...
      'StatClusters', []);
    
  case 'loadedsurface'
    template = struct(...
      'FileName',        '', ...
      'Name',            '', ...
      'Comment',         '', ...
      'Vertices',        [], ...
      'Faces',           [], ...
      'VertConn',        [], ...
      'VertNormals',     [], ...
      'VertArea',        [], ...
      'SulciMap',        [], ...
      'tess2mri_interp', [], ...  % Interpolation matrix (Surface -> MRI)
      'mrimask',         [], ...  % MRI mask
      'envelope',        [], ...
      'Atlas',           db_template('Atlas'), ...
      'iAtlas',          1, ...
      'isAtlasModified', 0);
    
    
  case 'loadedmri'
    template = struct(...
      'FileName',   '', ...
      'Comment',    '', ...
      'Cube',       [], ...
      'Voxsize',    [], ...
      'SCS',        [], ...
      'NCS',        [], ...
      'Header',     [], ...
      'Histogram',  [], ...
      'InitTransf', [], ...
      'History',    []);
    
  case 'figureid'
    template = struct(...
      'Type',           '', ...
      'SubType',        '', ...
      'Modality',       '');
    
  case 'figure'
    template = struct(...
      'Id',                    db_template('FigureId'), ...
      'hFigure',               0, ...
      'Handles',               struct(), ...
      'SelectedChannels',      []);
    
  case 'channeldesc'
    template = struct(...
      'Name',        '', ...
      'Comment',     '', ...
      'Type',        '', ...
      'Group',       [], ...
      'Loc',         [], ...
      'Orient',      [], ...
      'Weight',      []);
    
  case 'intraelectrode'
    template = struct(...
      'Name',  '', ...   % Identification
      'Type',  '', ...   % 'SEEG' / 'ECOG'
      'Model', '', ...   % String identifying the make and model
      'Loc',   [], ...   % [3xN] positions with all the relevant points (eg. tip and entry)
      'Color', [], ...   % [1x3] color vector
      'ContactNumber',   [], ...
      'ContactSpacing',  [], ...
      'ContactDiameter', [], ...
      'ContactLength',   [], ...
      'ElecDiameter',    [], ...
      'ElecLength',      [], ...
      'Visible',         1);
    
  case 'dataset'
    template = struct(...
      'DataFile',    '', ...
      'StudyFile',   '', ...
      'SubjectFile', '', ...
      'ChannelFile', '', ...
      'Surfaces',    repmat(db_template('LoadedSurface'), 0), ...
      'Measures',    db_template('Measures'), ...
      'Results',     repmat(db_template('LoadedResults'), 0), ...
      'Dipoles',     repmat(db_template('LoadedDipoles'), 0), ...
      'Timefreq',    repmat(db_template('LoadedTimefreq'), 0), ...
      'Matrix',      repmat(db_template('LoadedMatrix'), 0), ...
      'Channel',     repmat(db_template('ChannelDesc'), 0), ...
      'MegRefCoef',  [], ...
      'Projector',   repmat(db_template('Projector'), 0), ...
      'IntraElectrodes', repmat(db_template('IntraElectrode'), 0), ...
      'isChannelModified', 0, ...
      'HeadPoints',  [], ...
      'Figure',      repmat(db_template('Figure'), 0));
    
  case 'displayhandlestimeseries'
    template = struct(...
      'hAxes',         [], ...
      'hCursor',       [], ...
      'hTextCursor',   [], ...
      'hLines',        [], ...
      'hLinePatches',  [], ...
      'hLinesZeroY',   [], ...
      'LinesLabels',   [], ...
      'LinesColor',    [], ...
      'hColumnScale',  [], ...
      'hColumnScaleText', [], ...
      'hColumnScaleBar',  [], ...
      'ChannelOffsets',[], ...
      'DataMinMax',    [], ...
      'DisplayFactor', [], ...
      'DisplayUnits',  [], ...
      'DownsampleFactor', []);
  case 'displayhandlestopography'
    template = struct(...
      'hSurf',          [], ...
      'Wmat',           [], ...
      'DataMinMax',     [], ...
      'hSensorMarkers', [], ...
      'hSensorLabels',  [], ...
      'hSensorOrient',  [], ...
      'hContours',      [], ...
      'MarkersLocs',    [], ...
      'hLines',         [], ...  % 2D Layout
      'ChannelOffsets', [], ...  % 2D Layout
      'DisplayFactor',  1, ...   % 2D Layout
      'hCursors',       [], ...  % 2D Layout
      'hZeroLines',     [], ...  % 2D Layout
      'hAxesLegend',    [], ...  % 2D Layout
      'hLabelLegend',   [], ...  % 2D Layout
      'Channel',        [], ...  % 2D Layout
      'Vertices',       [], ...  % 2D Layout
      'SelChan',        [], ...  % 2D Layout
      'BoxesCenters',   [], ...  % 2D Layout
      'LinesColor',     []);     % 2D Layout
  case 'displayhandles3dviz'
    template = struct(...
      'hSensorMarkers', [], ...
      'hSensorLabels',  [], ...
      'hSensorOrient',  []);
  case 'displayhandlesimage'
    template = struct(...
      'Data',         [], ...
      'Labels',       [], ...
      'iDims',        [], ...
      'DimLabels',    [], ...
      'DataMinMax',   [], ...
      'ShowLabels',   [], ...
      'PageName',     []);
  case 'displayhandlesvideo'
    template = struct(...
      'hPlayer',     [], ...   % PlayerType = 'VideoReader', 'WMPlayer'
      'hMedia',      [], ...   % PlayerType = 'WMPlayer'
      'hImage',      [], ...   % PlayerType = 'VideoReader'
      'PlayerType',  '', ...   % {'VideoReader', 'WMPlayer'}
      'VideoStart',  0);
  case 'displayhandlestimefreq'
    template = struct(...
      'DataMinMax', []);
  case 'montage'
    template = struct(...
      'Name',      '', ...
      'Type',      '', ...  % {'selection', 'text', 'matrix'}
      'Matrix',    [], ...
      'DispNames', [], ...
      'ChanNames', []);
    template.DispNames = {};
    template.ChanNames = {};
  case 'atlas'
    template = struct(...
      'Name',   'User scouts', ...
      'Scouts', repmat(db_template('Scout'), 0));
    
  case 'scout'
    template = struct(...
      'Vertices',    [], ... % Index of vertices
      'Seed',        [], ... % Initial vertex of the scout area
      'Color',       [], ...
      'Label',       '', ...
      'Function',    'Mean', ... % Scout function: PCA, FastPCA, Mean, Mean_norm, Max, Power, All
      'Region',      'UU', ...      % 1st letter: Left/Right/Unknown,  2nd letter: Frontal/Parietal/Temporal/Occipital/Central/Unkown
      'Handles',     repmat(struct( ...
      'hFig',        [], ... % Figure handle in which the scout is displayed
      'hScout',      [], ... % Handles to the graphical scout objects
      'hLabel',      [], ...
      'hVertices',   [], ...
      'hPatch',      [], ...
      'hContour',    []), 0));
    %     case 'scoutmat'
    %         template = struct(...
    %             'Vertices',   [], ... % Index of vertices
    %             'Seed',       [], ... % Initial vertex of the scout area
    %             'Color',      [0 1 0], ...
    %             'Label',      '', ...
    %             'Function',   'Mean', ...
    %             'Region',     'UU');   % 1st letter: Left/Right/Unknown,  2nd letter: Frontal/Parietal/Temporal/Occipital/Central/Unkown
    
  case 'cluster'
    template = struct(...
      'Sensors',    '', ...   % File on which the scout is defined
      'Label',      '', ...   % Comment
      'Function',   'Mean');  % Cluster function: PCA, FastPCA, Mean, Max, Power, All
    
  case 'globaldata'
    template = struct(...
      'Program', struct(...
      'Version',           [], ...
      'BrainstormHomeDir', [], ...
      'ScreenDef',         [], ...
      'GuiLevel',          1, ...
      'GUI',               [], ...
      'CloneLock',         1, ...
      'ProgressBar',       [], ...
      'ColormapPanels',    repmat(struct( ...
      'ColormapType',  [], ...
      'jPanel',        []),0), ...
      'Clipboard',         struct(...
      'Nodes',         [], ...
      'isCut',         0), ...
      'FontCache',         struct(), ...
      'ProcessMenuCache',  struct()), ...
      'DataBase', struct(...
      'ProtocolInfo',       [], ...
      'ProtocolSubjects',   [], ...
      'ProtocolStudies',    [], ...
      'isProtocolLoaded',   [], ...
      'isProtocolModified', [], ...
      'iProtocol',          0, ...
      'BrainstormDbDir',    [], ...
      'DbVersion',          0, ...
      'isReadOnly',         0, ...
      'LastSavedTime',      0), ...
      'DataSet',  repmat(db_template('DataSet'), 0), ...
      'Mri',      repmat(db_template('LoadedMri'), 0), ...
      'Surface',  repmat(db_template('LoadedSurface'), 0), ...
      'UserTimeWindow', struct(...
      'Time',            [], ...
      'SamplingRate',    [], ...
      'NumberOfSamples', 0, ...
      'CurrentTime',     []), ...
      'FullTimeWindow', struct(...
      'Epochs', repmat(struct(...
      'Time',            [], ...
      'NumberOfSamples', 0), 0), ...
      'CurrentEpoch',    []), ...
      'UserFrequencies', struct(...
      'Freqs',        [], ...
      'iCurrentFreq', []), ...
      'ChannelEditor',  struct(...
      'ChannelFile',    '', ...
      'ChannelMat',     [], ...
      'DataFile',       [], ...
      'LocColumns',     [], ...
      'OrientColumns',  [], ...
      'isModified',     0), ...
      'Guidelines', [], ...  % Temporary variables for the guidelines panels
      'HeadModeler',    struct(...
      'BFS',            [], ...
      'nbSpheres',      [], ...
      'GUI',            struct(...
      'hFig',                     [], ...
      'Figure3DButtonDown_Bak',   [], ...
      'Figure3DButtonMotion_Bak', [], ...
      'Figure3DButtonUp_Bak',     [], ...
      'Figure3DCloseRequest_Bak', [], ...
      'selectedButton',           [], ...
      'mouseClicked',             [], ...
      'isClosing',                [], ...
      'hButtonTransX',            [], ...
      'hButtonTransY',            [], ...
      'hButtonTransZ',            [], ...
      'hButtonResize',            [])), ...
      'Clusters', repmat(db_template('Cluster'), 0), ...
      'CurrentFigure',        struct(...
      'Type3D', [], ...
      'Type2D', [], ...
      'TypeTF', [], ...
      'Last',   []), ...
      'DataViewer', struct(...
      'SelectedRows',  [], ...
      'DefaultFactor', []), ...
      'CurrentScoutsSurface', '', ...
      'VisualizationFilters', struct(...
      'LowPassEnabled',       0, ...
      'LowPassValue',         40, ...
      'HighPassEnabled',      0, ...
      'HighPassValue',        1, ...
      'SinRemovalEnabled',    0, ...
      'SinRemovalValue',      [], ...
      'MirrorEnabled',        0, ...
      'FullSourcesEnabled',   0), ...
      'Colormaps',            [], ...
      'Preferences',          [], ...
      'ChannelMontages', struct(...
      'CurrentMontage', struct(), ...
      'Montages', repmat(db_template('Montage'), 0)), ...
      'Processes', struct( ...
      'All',       [], ...
      'Current',   [], ...
      'Pipelines', repmat(struct(...
      'Name',      '', ...
      'Processes', []), 0), ...
      'Signature', []), ...
      'ProcessReports', struct(...
      'jFrameReport', [], ...
      'jTextHtml',    [], ...
      'CurrentFile',  [], ...
      'Reports',      []), ...
      'Interpolations', []);
    template.DataViewer.SelectedRows = {};
    
  case 'landmark'
    template = struct(...
      'Name',   '', ...
      'mriLoc', '');
  case 'scs'
    template = struct(...
      'NAS',    [], ...
      'LPA',    [], ...
      'RPA',    [], ...
      'R',      [], ...
      'T',      []);
  case 'ncs'
    template = struct(...
      'AC',    [], ...
      'PC',    [], ...
      'IH',    [], ...
      'R',     [], ...
      'T',     []);
    
    % ===== 3DViz appdata structure =====
  case 'tessinfo'
    anatomyColor = [.45*[1 1 1]; .6*[1 1 1]];
    template = struct(...
      'SurfaceFile',                '', ...
      'Name',                    '', ...
      'DataSource',              struct(...
      'Type',                '', ...   % {'data', 'results', 'stats', ...}
      'FileName',            '', ...
      'Atlas',               [], ...
      'GridAtlas',           [], ...
      'GridLoc',             [], ...
      'GridSmooth',          1), ...
      'ColormapType',            '', ...
      'hPatch',                  [], ...
      'nVertices',               0, ...
      'nFaces',                  0, ...
      'SurfAlpha',               0, ...    % Surface transparency
      'SurfShowSulci',           0, ...    % Toggle show/hide surface sulci map viewing
      'SurfShowEdges',           0, ...    % Toggle oon/off surface edges display
      'AnatomyColor',            anatomyColor, ... % RGB color for sulci map encoding
      'SurfSmoothValue',         0, ...
      'Data',                    [], ...   % MEG, EEG or current density for overlay to anatomy (needs to be compatible in size with FaceVertexCdata patch property)
      'DataMinMax',              [], ...   % Minimum and maximum of the DataSource.FileName file
      'DataWmat',                [], ...   % Interpolation matrix (transformation to map Data on hPatch surface)
      'OverlayCube',             [], ...   % Interpolated results in a MRI volume
      'DataAlpha',               0, ...    % Alpha for blending of anatomy and surface data
      'DataThreshold',           0.5, ...  % Threshold to apply to color coding of data values
      'SizeThreshold',           1, ...    % Threshold to apply to color coding of data values
      'DataLimitValue',          [], ...   % Relative limits for colormapping
      'CutsPosition',            [0 0 0], ...   % Position of the three orthogonal MRI slices
      'Resect',                  'none', ...    % Either [x,y,z] resect values, or {'left', 'right', 'none'}
      'MipAnatomy',              [], ...        % 3 cells: Maximum intensity power in each direction (MRI amplitudes)
      'MipFunctional',           [] ...         % 3 cells: Maximum intensity power in each direction (sources amplitudes)
      );
    template.MipAnatomy = cell(3,1);
    template.MipFunctional = cell(3,1);
    
  case 'tsinfo'
    template = struct(...
      'FileName',        '', ...
      'Modality',        '', ...
      'DisplayMode',     '', ...
      'LinesLabels',     [], ...
      'AxesLabels',      [], ...
      'LinesColor',      [], ...
      'RowNames',        [], ...
      'MontageName',     [], ...
      'DefaultFactor',   [], ...
      'FlipYAxis',       0, ...
      'AutoScaleY',      1, ...
      'NormalizeAmp',    0, ...
      'Resolution',      [0 0], ...
      'ShowEvents',      1, ...
      'ShowLegend',      [], ...
      'YLabel',          [], ...
      'ShowXGrid',       0, ...
      'ShowYGrid',       0);
    
  case 'topoinfo'
    template = struct(...
      'FileName',      '', ...
      'Modality',      '', ...
      'FileType',      '', ...
      'TopoType',      '', ...
      'DataToPlot',    [], ...
      'UseSmoothing',  1);
    
  case 'tfinfo'
    template = struct(...
      'FileName',        '', ...
      'Comment',         '', ...
      'DisplayMode',     '', ...
      'Function',        'power', ...
      'HideEdgeEffects', 0, ...
      'HighResolution',  0, ...
      'iFreqs',          [], ...
      'RowName',         [], ...
      'RefRowName',      [], ...
      'InputTarget',     []);
    
  case 'nodelist'
    template = struct(...
      'name',       '', ...
      'comment',    '', ...
      'type',       '', ...
      'jPanel',     [], ...
      'jBorder',    [], ...
      'jTree',      [], ...
      'jPanelTag',  [], ...
      'jCheckTag',  [], ...
      'contents',   [], ...
      'isStat',     0);
    
  case 'processfile'
    template = struct(...
      'iStudy',       0, ...
      'iItem',        0, ...
      'FileName',     '', ...
      'FileType',     '', ...
      'Comment',      '', ...
      'Condition',    '', ...
      'SubjectFile',  '', ...
      'SubjectName',  '', ...
      'DataFile',     '', ...
      'ChannelFile',  '', ...
      'ChannelTypes', '');
    
  case 'importfile'
    template = struct(...
      'iStudy',       0, ...
      'iItem',        0, ...
      'FileName',     '', ...
      'FileType',     'import', ...
      'Comment',      'import', ...
      'Condition',    'import', ...
      'SubjectFile',  '', ...
      'SubjectName',  '', ...
      'DataFile',     '', ...
      'ChannelFile',  '', ...
      'ChannelTypes', []);
    
  case 'processdesc'
    template = struct(...
      ... % Process description
      'Function',    [], ...
      'Comment',     '', ...
      'FileTag',     '', ...
      'Description', '', ...
      'Category',    '', ...
      'SubGroup',    '', ...
      'Index',       0, ...
      'isSeparator', 0, ...
      ... % Input type
      'InputTypes',  [], ...
      'OutputTypes', [], ...
      'nInputs',     1, ...
      'nOutputs',    1, ...
      'nMinFiles',   1, ...
      'isPaired',    0, ...
      'isSourceAbsolute', -1, ...
      'processDim',   [], ...
      'options',      [] ...
      );
    template.InputTypes = {};
    template.OutputTypes = {};
    
  case 'interpolation'
    template = struct(...
      'WInterp',   [], ...
      'Signature', []);
    
  otherwise
    error('Unknown data template : %s', structureName);
end


function splStr = str_split( str, delimiters, isCollapse )
% STR_SPLIT: Split string.
%
% USAGE:  str_split( str, delimiters, isCollapse=1 ) : delimiters in an array of char delimiters
%         str_split( str )             : default are file delimiters ('\' and '/')
%
% INPUT:
%    - str        : String to split
%    - delimiters : String that contains all the characters used to split, default = '/\'
%    - isCollapse : If 1, remove all the empty entries
%
% OUTPUT:
%    - splStr : cell array of blocks found between separators

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
%
% Copyright (c)2000-2018 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
%
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Francois Tadel, 2008-2014

% Default delimiters: file delimiters ('\', '/')
if (nargin < 3) || isempty(isCollapse)
  isCollapse = 1;
end
if (nargin < 2) || isempty(delimiters)
  delimiters = '/\';
end
% Empty input
if isempty(str)
  splStr = {};
  return
end

% Find all delimiters in string
iDelim = [];
for i=1:length(delimiters)
  iDelim = [iDelim strfind(str, delimiters(i))];
end
iDelim = unique(iDelim);

% If no delimiter: return the whole string
if isempty(iDelim)
  splStr = {str};
  return
end

% Allocates the split array
splStr = cell(1, length(iDelim)+1);

% First part (before first delimiter)
if (iDelim(1) ~= 1)
  iSplitStr = 1;
  splStr{iSplitStr} = str(1:iDelim(1)-1);
else
  iSplitStr = 0;
end

% Loop over all other delimiters
for i = 2:length(iDelim)
  if (isCollapse  && (iDelim(i) - iDelim(i-1) > 1)) || ...
      (~isCollapse && (iDelim(i) - iDelim(i-1) >= 1))
    iSplitStr = iSplitStr + 1;
    splStr{iSplitStr} = str(iDelim(i-1)+1:iDelim(i)-1);
  end
end

% Last part (after last delimiter)
if (iDelim(end) ~= length(str))
  iSplitStr = iSplitStr + 1;
  splStr{iSplitStr} = str(iDelim(end)+1:end);
end

% Remove all the unused entries
if (iSplitStr < length(splStr))
  splStr(iSplitStr+1:end) = [];
end


function strDate = str_date(s, dateFormat)
% STR_Date: Reformat date string to dd-MMM-yyyy.

% @=============================================================================
% This function is part of the Brainstorm software:
% https://neuroimage.usc.edu/brainstorm
%
% Copyright (c)2000-2018 University of Southern California & McGill University
% This software is distributed under the terms of the GNU General Public License
% as published by the Free Software Foundation. Further details on the GPLv3
% license can be found at http://www.gnu.org/copyleft/gpl.html.
%
% FOR RESEARCH PURPOSES ONLY. THE SOFTWARE IS PROVIDED "AS IS," AND THE
% UNIVERSITY OF SOUTHERN CALIFORNIA AND ITS COLLABORATORS DO NOT MAKE ANY
% WARRANTY, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, NOR DO THEY ASSUME ANY
% LIABILITY OR RESPONSIBILITY FOR THE USE OF THIS SOFTWARE.
%
% For more information type "brainstorm license" at command prompt.
% =============================================================================@
%
% Authors: Francois Tadel, 2018

% Parse inputs
if (nargin < 2) || isempty(dateFormat)
  dateFormat = [];
end
% Clean string
if ischar(s)
  s = strtrim(strrep(s, char(0), ''));
end
% Check various input formats
try
  if ~isempty(dateFormat) && strcmpi(dateFormat, 'posix')
    strDate = datestr(double(s) ./ 86400 + datenum(1970,1,1,0,0,0), 'dd-mmm-yyyy');
  elseif ~isempty(dateFormat)
    strDate = datestr(datenum(s, dateFormat), 'dd-mmm-yyyy');
  elseif isequal(find(s == '/'), [3 6]) && ((length(s) == 10) || (length(s) == 19))
    strDate = datestr(datenum(s, 'dd/mm/yyyy'), 'dd-mmm-yyyy');
  elseif isequal(find(s == '/'), [3 6]) && ((length(s) == 8) || (length(s) == 17))
    strDate = datestr(datenum(s, 'dd/mm/yy'), 'dd-mmm-yyyy');
  elseif isequal(find(s == '.'), [3 6]) && ((length(s) == 10) || (length(s) == 19))
    strDate = datestr(datenum(s, 'dd.mm.yyyy'), 'dd-mmm-yyyy');
  elseif isequal(find(s == '.'), [3 6]) && ((length(s) == 8) || (length(s) == 17))
    strDate = datestr(datenum(s, 'dd.mm.yy'), 'dd-mmm-yyyy');
  elseif isequal(find(s == '-'), [3 6]) && ((length(s) == 10) || (length(s) == 19))
    strDate = datestr(datenum(s, 'dd-mm-yyyy'), 'dd-mmm-yyyy');
  elseif isequal(find(s == '-'), [3 7]) && (length(s) == 11)
    strDate = datestr(datenum(s, 'dd-mmm-yyyy'), 'dd-mmm-yyyy');
  elseif isequal(find(s == '-'), [5 8]) && ((length(s) == 10) || (length(s) == 19))
    strDate = datestr(datenum(s, 'yyyy-mm-dd'), 'dd-mmm-yyyy');
  else
    strDate = [];
  end
catch
  strDate = [];
end
